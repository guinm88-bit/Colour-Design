<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Plaid Master Interactive</title>
    <style>
        :root {
            --primary: #2563eb;
            --bg: #f1f5f9;
            --panel: #ffffff;
            --border: #cbd5e1;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: var(--bg);
            margin: 0; padding: 0; padding-bottom: 100px;
            color: #1e293b;
        }

        /* COMPACT STICKY PREVIEW */
        .preview-header {
            position: sticky; top: 0; z-index: 100;
            background: #fff; padding: 10px;
            border-bottom: 1px solid var(--border);
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        canvas {
            width: 220px; /* Smaller mobile-friendly size */
            height: 220px;
            background: #fff;
            border: 1px solid #94a3b8;
            display: block;
            margin: 0 auto;
            touch-action: none; /* Prevent scrolling when painting on canvas */
        }
        .canvas-hint { font-size: 10px; color: #64748b; margin-top: 4px; }

        /* TAB SYSTEM */
        .tabs { display: flex; background: #fff; border-bottom: 1px solid var(--border); }
        .tab { flex: 1; padding: 12px; text-align: center; font-size: 13px; font-weight: bold; color: #64748b; border-bottom: 2px solid transparent; }
        .tab.active { color: var(--primary); border-bottom-color: var(--primary); }

        .section { display: none; padding: 15px; }
        .section.active { display: block; }

        /* TOOLS */
        .tool-box { background: #fff; border-radius: 12px; padding: 15px; margin-bottom: 15px; border: 1px solid var(--border); }
        .flex-row { display: flex; align-items: center; gap: 10px; }
        
        /* HARMONY COLORS */
        .harmony-label { font-size: 11px; font-weight: 700; color: #94a3b8; text-transform: uppercase; margin-top: 10px; display: block; }
        .scroll-row { display: flex; gap: 8px; overflow-x: auto; padding: 5px 0; scrollbar-width: none; }
        .scroll-row::-webkit-scrollbar { display: none; }
        .swatch { width: 44px; height: 44px; border-radius: 8px; flex-shrink: 0; border: 1px solid rgba(0,0,0,0.1); }
        .swatch.active { border: 3px solid var(--primary); box-shadow: 0 0 8px rgba(37,99,235,0.4); }

        /* PATTERN ROWS */
        .thread-row { 
            background: #f8fafc; border: 1px solid var(--border); 
            border-radius: 10px; padding: 10px; margin-bottom: 8px;
            display: flex; align-items: center; gap: 10px;
        }
        .color-dot { width: 30px; height: 30px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .input-group { display: flex; align-items: center; background: #fff; border-radius: 6px; border: 1px solid var(--border); overflow: hidden; }
        .input-group input { 
            width: 50px; border: none; text-align: center; font-weight: bold; font-size: 16px; 
            padding: 8px 0; outline: none; 
        }
        .step-btn { background: #f1f5f9; border: none; padding: 8px 12px; font-size: 18px; font-weight: bold; }

        /* FOOTER */
        .footer { position: fixed; bottom: 0; left: 0; right: 0; padding: 15px; background: #fff; border-top: 1px solid var(--border); display: flex; gap: 10px; }
        button.main-btn { flex: 1; background: var(--primary); color: #fff; border: none; padding: 14px; border-radius: 10px; font-weight: bold; font-size: 16px; }
        
        .zoom-container { padding: 10px; text-align: center; }
        input[type="range"] { width: 80%; }
    </style>
</head>
<body>

<div class="preview-header">
    <canvas id="plaidCanvas" width="400" height="400"></canvas>
    <div class="canvas-hint">Tap on pattern to paint with Base Color</div>
    <div class="zoom-container">
        <span style="font-size:12px">Thread Scale:</span>
        <input type="range" id="zoom" min="1" max="10" value="4" oninput="render()">
    </div>
</div>

<div class="tabs">
    <div class="tab active" onclick="switchTab(0)">1. Colors</div>
    <div class="tab" onclick="switchTab(1)">2. Pattern</div>
</div>

<!-- COLORS SECTION -->
<div id="sec-0" class="section active">
    <div class="tool-box">
        <div class="flex-row">
            <input type="color" id="baseColorInput" value="#4f46e5" oninput="setBase(this.value)" style="width:60px; height:60px; border:none; border-radius:10px;">
            <div>
                <strong>Base Color</strong><br>
                <small>Used for painting threads</small>
            </div>
        </div>
    </div>

    <h3>Combinations</h3>
    <div id="harmonies"></div>

    <h3>Active Palette</h3>
    <div id="paletteList" class="scroll-row"></div>
</div>

<!-- PATTERN SECTION -->
<div id="sec-1" class="section">
    <div style="margin-bottom: 15px; font-size: 14px;">
        <label><input type="checkbox" id="linkWeft" checked onchange="toggleWeft()"> Synchronize Warp/Weft</label><br>
        <label><input type="checkbox" id="mirror" checked onchange="render()"> Mirror Sequence</label>
    </div>

    <h4>Warp Threads (Vertical)</h4>
    <div id="warpList"></div>
    <button onclick="addThread('warp')" style="width:100%; padding:10px; border-radius:8px; border:1px dashed var(--primary); background:none; color:var(--primary); font-weight:bold;">+ Add Thread</button>

    <div id="weftGroup" style="display:none; margin-top:20px;">
        <h4>Weft Threads (Horizontal)</h4>
        <div id="weftList"></div>
        <button onclick="addThread('weft')" style="width:100%; padding:10px; border-radius:8px; border:1px dashed var(--primary); background:none; color:var(--primary); font-weight:bold;">+ Add Thread</button>
    </div>
</div>

<div class="footer">
    <button class="main-btn" onclick="saveImage()">Download PNG</button>
</div>

<script>
    let baseColor = "#4f46e5";
    let palette = ["#4f46e5", "#ffffff", "#1e293b", "#f43f5e"];
    let warp = [{ color: "#4f46e5", width: 10 }, { color: "#ffffff", width: 2 }];
    let weft = [{ color: "#4f46e5", width: 10 }, { color: "#ffffff", width: 2 }];

    const canvas = document.getElementById('plaidCanvas');
    const ctx = canvas.getContext('2d');

    // --- TAB LOGIC ---
    function switchTab(idx) {
        document.querySelectorAll('.tab').forEach((t, i) => t.classList.toggle('active', i === idx));
        document.querySelectorAll('.section').forEach((s, i) => s.classList.toggle('active', i === idx));
    }

    // --- COLOR LOGIC ---
    function setBase(hex) {
        baseColor = hex;
        if (!palette.includes(hex)) palette.push(hex);
        updateUI();
    }

    function updateUI() {
        renderHarmonies();
        renderPalette();
        renderThreadLists();
        render();
    }

    function renderHarmonies() {
        const container = document.getElementById('harmonies');
        container.innerHTML = '';
        const hsl = hexToHsl(baseColor);
        const schemes = {
            "Complementary": [rotateHsl(hsl, 180)],
            "Monochromatic": [lightenHsl(hsl, 20), lightenHsl(hsl, -20)],
            "Triadic": [rotateHsl(hsl, 120), rotateHsl(hsl, 240)],
            "Tetradic": [rotateHsl(hsl, 90), rotateHsl(hsl, 180), rotateHsl(hsl, 270)]
        };

        for (let type in schemes) {
            container.innerHTML += `<span class="harmony-label">${type}</span>`;
            const row = document.createElement('div');
            row.className = 'scroll-row';
            schemes[type].forEach(c => {
                const hex = hslToHex(c.h, c.s, c.l);
                row.innerHTML += `<div class="swatch" style="background:${hex}" onclick="setBase('${hex}')"></div>`;
            });
            container.appendChild(row);
        }
    }

    function renderPalette() {
        const list = document.getElementById('paletteList');
        list.innerHTML = '';
        palette.forEach(hex => {
            const active = (hex === baseColor) ? 'active' : '';
            list.innerHTML += `<div class="swatch ${active}" style="background:${hex}" onclick="setBase('${hex}')"></div>`;
        });
    }

    // --- PATTERN LOGIC ---
    function toggleWeft() {
        document.getElementById('weftGroup').style.display = document.getElementById('linkWeft').checked ? 'none' : 'block';
        render();
    }

    function addThread(type) {
        const target = (type === 'warp') ? warp : weft;
        target.push({ color: baseColor, width: 4 });
        updateUI();
    }

    function renderThreadLists() {
        ['warp', 'weft'].forEach(type => {
            const container = document.getElementById(type + 'List');
            const data = (type === 'warp') ? warp : weft;
            container.innerHTML = '';
            data.forEach((t, i) => {
                const row = document.createElement('div');
                row.className = 'thread-row';
                row.innerHTML = `
                    <div class="color-dot" style="background:${t.color}"></div>
                    <div class="input-group">
                        <button class="step-btn" onclick="adjustWidth('${type}', ${i}, -1)">-</button>
                        <input type="number" inputmode="numeric" value="${t.width}" onchange="updateWidth('${type}', ${i}, this.value)">
                        <button class="step-btn" onclick="adjustWidth('${type}', ${i}, 1)">+</button>
                    </div>
                    <button onclick="removeThread('${type}', ${i})" style="margin-left:auto; background:none; border:none; color:#ef4444;">âœ•</button>
                `;
                container.appendChild(row);
            });
        });
    }

    function adjustWidth(type, i, delta) {
        const target = (type === 'warp') ? warp : weft;
        target[i].width = Math.max(1, target[i].width + delta);
        updateUI();
    }

    function updateWidth(type, i, val) {
        const target = (type === 'warp') ? warp : weft;
        target[i].width = Math.max(1, parseInt(val) || 1);
        render();
    }

    function removeThread(type, i) {
        const target = (type === 'warp') ? warp : weft;
        target.splice(i, 1);
        updateUI();
    }

    // --- INTERACTIVE PAINTING ---
    canvas.addEventListener('pointerdown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        const zoom = parseInt(document.getElementById('zoom').value);
        const warpSeq = getFullSeq(warp);
        const weftSeq = document.getElementById('linkWeft').checked ? warpSeq : getFullSeq(weft);

        // Find which thread object index was clicked
        if (warpSeq.length > 0) {
            const warpIdxAtPixel = Math.floor(x / zoom) % warpSeq.length;
            const warpThreadIdx = getThreadIndexAtSequencePos(warp, warpIdxAtPixel);
            if (warpThreadIdx !== -1) warp[warpThreadIdx].color = baseColor;
        }

        if (weftSeq.length > 0) {
            const weftIdxAtPixel = Math.floor(y / zoom) % weftSeq.length;
            const weftThreadIdx = getThreadIndexAtSequencePos(document.getElementById('linkWeft').checked ? warp : weft, weftIdxAtPixel);
            if (weftThreadIdx !== -1) {
                if (document.getElementById('linkWeft').checked) warp[weftThreadIdx].color = baseColor;
                else weft[weftThreadIdx].color = baseColor;
            }
        }
        updateUI();
    });

    function getThreadIndexAtSequencePos(threadArr, pos) {
        let currentPos = 0;
        const mirror = document.getElementById('mirror').checked;
        
        // Handle mirrored logic
        let fullArr = [...threadArr];
        if (mirror && threadArr.length > 1) {
            const mirrorPart = [...threadArr].slice(0, -1).reverse();
            fullArr = threadArr.concat(mirrorPart);
        }

        for (let i = 0; i < fullArr.length; i++) {
            currentPos += fullArr[i].width;
            if (pos < currentPos) {
                // Return the original index from threadArr
                if (mirror && i >= threadArr.length) {
                    return (threadArr.length - 2) - (i - threadArr.length);
                }
                return i;
            }
        }
        return -1;
    }

    // --- RENDER ENGINE ---
    function render() {
        const zoom = parseInt(document.getElementById('zoom').value);
        const warpSeq = getFullSeq(warp);
        const weftSeq = document.getElementById('linkWeft').checked ? warpSeq : getFullSeq(weft);

        if (!warpSeq.length || !weftSeq.length) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < canvas.width / zoom; i++) {
            for (let j = 0; j < canvas.height / zoom; j++) {
                const c1 = warpSeq[i % warpSeq.length];
                const c2 = weftSeq[j % weftSeq.length];
                ctx.fillStyle = blend(c1, c2);
                ctx.fillRect(i * zoom, j * zoom, zoom, zoom);
            }
        }
    }

    function getFullSeq(arr) {
        let s = [];
        arr.forEach(t => { for(let i=0; i<t.width; i++) s.push(t.color); });
        if (document.getElementById('mirror').checked && arr.length > 1) {
            const lastW = arr[arr.length-1].width;
            s = s.concat([...s].slice(0, -lastW).reverse());
        }
        return s;
    }

    function blend(hex1, hex2) {
        const r1 = parseInt(hex1.substr(1,2),16), g1 = parseInt(hex1.substr(3,2),16), b1 = parseInt(hex1.substr(5,2),16);
        const r2 = parseInt(hex2.substr(1,2),16), g2 = parseInt(hex2.substr(3,2),16), b2 = parseInt(hex2.substr(5,2),16);
        return `rgb(${(r1+r2)/2}, ${(g1+g2)/2}, ${(b1+b2)/2})`;
    }

    // --- MATH HELPERS ---
    function hexToHsl(hex) {
        let r = parseInt(hex.substr(1,2),16)/255, g = parseInt(hex.substr(3,2),16)/255, b = parseInt(hex.substr(5,2),16)/255;
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if(max == min) h = s = 0;
        else {
            let d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h * 360, s: s * 100, l: l * 100 };
    }
    function hslToHex(h, s, l) {
        l /= 100; const a = s * Math.min(l, 1 - l) / 100;
        const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
    }
    function rotateHsl(hsl, deg) { return { ...hsl, h: (hsl.h + deg) % 360 }; }
    function lightenHsl(hsl, amt) { return { ...hsl, l: Math.max(0, Math.min(100, hsl.l + amt)) }; }

    function saveImage() {
        const a = document.createElement("a");
        a.download = "my-plaid.png";
        a.href = canvas.toDataURL();
        a.click();
    }

    updateUI();
</script>

</body>
</html>